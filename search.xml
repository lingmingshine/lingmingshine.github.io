<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法之参考思路</title>
      <link href="/2020/10/10/project_20201010/"/>
      <url>/2020/10/10/project_20201010/</url>
      
        <content type="html"><![CDATA[<p>滚动数组：</p><p>用于动态规划的空间优化，主要思想：</p><p><strong>只保存需要用到的子问题的答案（状态），覆盖那些不需要用到的子问题的答案，状态在同一块空间中不断翻滚迭代向前</strong>。</p><p>1.最长公共子串</p><p>dp/空间优化滚动数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(String text1,String text2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> length1 = text1.length();</span><br><span class="line"><span class="keyword">int</span> length2 = text2.length();</span><br><span class="line"><span class="comment">//dp[i][j] </span></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length1 + <span class="number">1</span>][length2 + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] textArr1 = text1.toCharArray();</span><br><span class="line"><span class="keyword">char</span>[] textArr2 = text2.toCharArray();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= length1;++i) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; length2;++j) &#123;</span><br><span class="line"><span class="keyword">if</span>(textArr1[i-<span class="number">1</span>] == textArr2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[length1][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要理解dp数组的含义：dp[i][j]表示对于字符串 <code>&quot;&quot;</code> 和 <code>&quot;bab&quot;</code>，其 公共子串 的长度为 0。因为有一个字符串是空串，它们的最长公共子序列的长度显然应该是 0。</p><p>2.最长不含重复字符的子字符串</p><p>dp/滑动窗口/双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; dic = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = dic.getOrDefault(s.charAt(j), -<span class="number">1</span>); <span class="comment">// 获取索引 i</span></span><br><span class="line">            dic.put(s.charAt(j), j); <span class="comment">// 更新哈希表</span></span><br><span class="line">            tmp = tmp &lt; j - i ? tmp + <span class="number">1</span> : j - i; <span class="comment">// dp[j - 1] -&gt; dp[j]</span></span><br><span class="line">            res = Math.max(res, tmp); <span class="comment">// max(dp[j - 1], dp[j])</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3.矩阵路径</p><p>dfs深度搜索优先</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i &lt; board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board,words,i,j,<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">char</span>[] word,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= board.length || i &lt; <span class="number">0</span> || j&gt;= board[<span class="number">0</span>].length ||j&lt;<span class="number">0</span>|| board[i][j] != word[k]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == word.length -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">char</span> tmp = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">'/'</span>;</span><br><span class="line">        <span class="keyword">boolean</span> res = dfs(board,word,i+<span class="number">1</span>,j,k+<span class="number">1</span>) || dfs(board,word,i-<span class="number">1</span>,j,k+<span class="number">1</span>) ||</span><br><span class="line">                        dfs(board,word,i,j+<span class="number">1</span>,k+<span class="number">1</span>) || dfs(board,word,i,j-<span class="number">1</span>,k+<span class="number">1</span>);</span><br><span class="line">        board[i][j] = tmp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要理解dfs的递归方式，注意base条件，递归顺序为：下上右左</p><p>4.数字序列中的某一位的数字</p><p>数学找规律</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> digit  = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span>  count = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; count)&#123;</span><br><span class="line">            n -= count;</span><br><span class="line">            digit++;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            count = digit * start * <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> num = start + (n-<span class="number">1</span>)/digit;</span><br><span class="line">        <span class="keyword">return</span> Long.toString(num).charAt((n-<span class="number">1</span>)%digit)-<span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* 数字范围    数量  位数    占多少位</span><br><span class="line">    1-9        9      1       9</span><br><span class="line">    10-99      90     2       180</span><br><span class="line">    100-999    900    3       2700</span><br><span class="line">    1000-9999  9000   4       36000  ...</span><br><span class="line"></span><br><span class="line">    例如 2901 = 9 + 180 + 2700 + 12 即一定是4位数,第12位   n = 12;</span><br><span class="line">    数据为 = 1000 + (12 - 1)/ 4  = 1000 + 2 = 1002</span><br><span class="line">    定位1002中的位置 = (n - 1) %  4 = 3    s.charAt(3) = 2;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>评论区里面的大佬的思路，刚开始也是想到这个，但是觉得太繁琐，就没想深究下去。最后发现这种方法竟然还不错。</p><p>总结：有思路就应该尽快实现出来，要不然很多时候反而想得太深，最后到头来花更多时间都做不出来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法之路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三种设计模式的简单了解</title>
      <link href="/2020/10/09/project_20201009/"/>
      <url>/2020/10/09/project_20201009/</url>
      
        <content type="html"><![CDATA[<h4 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="观察者模式："></a>观察者模式：</h4><p>定义：</p><p>对象存在一对多关系，当一个对象被修改时，则会自动通知依赖它的对象。</p><blockquote><p>观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。观察者模式是一种对象行为型模式。</p><p>观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</p></blockquote><p><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们。</p><p><strong>使用场景：</strong></p><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><h4 id="简单工厂模式："><a href="#简单工厂模式：" class="headerlink" title="简单工厂模式："></a>简单工厂模式：</h4><p>并不算一种设计模式，更多是一种编程习惯。定义的工厂类，根据传入参数的不同，被创建的实例具有相同的父类或者接口。总的来说就是屏蔽掉创建实例的细节，交由工厂类来创建。</p><p>factory method ：工厂方法</p><p>适用场景：</p><p>1.需要创建的对象较少</p><p>2.客户端不关心对象的创建过程</p><h4 id="工厂方法模式："><a href="#工厂方法模式：" class="headerlink" title="工厂方法模式："></a>工厂方法模式：</h4><p>区别于简单工厂模式，主要是针对不同的对象提供不同的工厂。每个对象都有与之相对应的工厂。</p><p>适用场景：</p><p>1.客户端不需要知道它所创建的对象的类</p><p>2.客户端可以通过子类来指定创建对应的对象</p><h4 id="抽象工厂模式："><a href="#抽象工厂模式：" class="headerlink" title="抽象工厂模式："></a>抽象工厂模式：</h4><p>了解即可，不想深入。。。</p><p>抽象工厂模式是工厂方法的进一步深化，在这个模式中的工厂类不单单可以创建一个对象，而是可以创建<strong>一组对象</strong>。这是和工厂方法最大的不同点。</p><h5 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h5><p><a href="https://juejin.im/entry/6844903474639929357" target="_blank" rel="noopener">https://juejin.im/entry/6844903474639929357</a></p><p>反射：invoke方法</p><p><a href="https://www.cnblogs.com/onlywujun/p/3519037.html" target="_blank" rel="noopener">https://www.cnblogs.com/onlywujun/p/3519037.html</a></p><p>设计模式博客：</p><p><a href="https://blog.csdn.net/LoveLion/article/details/17517213" target="_blank" rel="noopener">https://blog.csdn.net/LoveLion/article/details/17517213</a></p><h5 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h5><p>博客终究是经过一层消化过来的知识，所以深浅自知，可能对于入门是个不错的开始，但是深入知识点还是回归课本吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记</title>
      <link href="/2020/10/05/%E7%AE%97%E6%B3%954%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/10/05/%E7%AE%97%E6%B3%954%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>算法4应该是很多前辈推荐的一本算法入门书了，因为这本书是以Java为基础语言的，所以本书会假定读者没有Java基础，会以一章节的内容来大概梳理一下这门优秀的面向对象语言知识。然后开始以入门排序算法的介绍一章节，来让我们先了解这些基础算法内容，但是我看的主要是堆排，快排，归并排这三种，其中的原地归并排序是先需要了解手摇算法这个为前提，要不然很容易整懵了，本书很多这些地方，说是入门书，其实很多的名词都要有一定的了解到。这是我目前学习的到的地方。                                                                                                                                        第一章，第二章20201005</p></blockquote><h4 id="算法4读书笔记"><a href="#算法4读书笔记" class="headerlink" title="算法4读书笔记"></a>算法4读书笔记</h4><p>​                                                                                                                                                    </p><p>​    Java的基础部分，包括：原始数据类型，语句（声明语句，赋值语句，条件语句，循环语句），数组，静态方法，字符串等一系列快速浏览了一遍。</p><p>基础的二分查找，作为本书开头的第一个高效率和广泛应用的查找算法。</p><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span>[] a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt; key) &#123;</span><br><span class="line">            <span class="keyword">return</span> rank(key,a,left,mid - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &lt; key) &#123;</span><br><span class="line">            <span class="keyword">return</span> rank(key,a,mid + <span class="number">1</span>,right);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="思考问题："><a href="#思考问题：" class="headerlink" title="思考问题："></a>思考问题：</h6><p>​    二分法的变形</p><h5 id="字符串，判断是否为回文串："><a href="#字符串，判断是否为回文串：" class="headerlink" title="字符串，判断是否为回文串："></a>字符串，判断是否为回文串：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N / <span class="number">2</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != s.charAt(N-i-<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="思考问题：-1"><a href="#思考问题：-1" class="headerlink" title="思考问题："></a>思考问题：</h6><p>​    回文串的变形题</p><h5 id="重写equals方法模板："><a href="#重写equals方法模板：" class="headerlink" title="重写equals方法模板："></a>重写equals方法模板：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == x) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.getClass() != x.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Holiday that = (Holiday)x;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.day != that.day) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.month != that.day) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.year != that.year) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="思考问题：-2"><a href="#思考问题：-2" class="headerlink" title="思考问题："></a>思考问题：</h6><p>​    重写equal是在什么情况下，为什么要重写，重写的意义在哪。</p><h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
